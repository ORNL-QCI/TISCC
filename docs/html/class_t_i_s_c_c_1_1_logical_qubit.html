<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TISCC: TISCC::LogicalQubit Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TISCC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>TISCC</b></li><li class="navelem"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_t_i_s_c_c_1_1_logical_qubit-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TISCC::LogicalQubit Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and to generate circuits for a set of primitive patch operations.  
 <a href="class_t_i_s_c_c_1_1_logical_qubit.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="logicalqubit_8hpp_source.html">logicalqubit.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9e79d6c719e33b9465e1b791f69421a8" id="r_a9e79d6c719e33b9465e1b791f69421a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a9e79d6c719e33b9465e1b791f69421a8">LogicalQubit</a> (unsigned int dx, unsigned int dz, unsigned int row, unsigned int col, <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid)</td></tr>
<tr class="memdesc:a9e79d6c719e33b9465e1b791f69421a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html" title="Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and t...">LogicalQubit</a> class.  <br /></td></tr>
<tr class="separator:a9e79d6c719e33b9465e1b791f69421a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5efd62193536bce72fad7a2cdb48078" id="r_af5efd62193536bce72fad7a2cdb48078"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#af5efd62193536bce72fad7a2cdb48078">get_dx</a> () const</td></tr>
<tr class="memdesc:af5efd62193536bce72fad7a2cdb48078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current x code distance.  <br /></td></tr>
<tr class="separator:af5efd62193536bce72fad7a2cdb48078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59152c30cb3ec54734b4c9d9530f0d84" id="r_a59152c30cb3ec54734b4c9d9530f0d84"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a59152c30cb3ec54734b4c9d9530f0d84">get_dz</a> () const</td></tr>
<tr class="memdesc:a59152c30cb3ec54734b4c9d9530f0d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current z code distance.  <br /></td></tr>
<tr class="separator:a59152c30cb3ec54734b4c9d9530f0d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97658e584b8fdf6de35d6e869e80992" id="r_aa97658e584b8fdf6de35d6e869e80992"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#aa97658e584b8fdf6de35d6e869e80992">get_dx_init</a> () const</td></tr>
<tr class="memdesc:aa97658e584b8fdf6de35d6e869e80992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get initial x code distance.  <br /></td></tr>
<tr class="separator:aa97658e584b8fdf6de35d6e869e80992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c9370ea8977bc77715ad6e126656c4" id="r_ac2c9370ea8977bc77715ad6e126656c4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#ac2c9370ea8977bc77715ad6e126656c4">get_dz_init</a> () const</td></tr>
<tr class="memdesc:ac2c9370ea8977bc77715ad6e126656c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get initial z code distance.  <br /></td></tr>
<tr class="separator:ac2c9370ea8977bc77715ad6e126656c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ea50b65c1990ef1d8716c70b80be25" id="r_a46ea50b65c1990ef1d8716c70b80be25"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a46ea50b65c1990ef1d8716c70b80be25">get_row</a> () const</td></tr>
<tr class="memdesc:a46ea50b65c1990ef1d8716c70b80be25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hardware grid row specifying the top-left corner of the logical tile on which this patch lives.  <br /></td></tr>
<tr class="separator:a46ea50b65c1990ef1d8716c70b80be25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab129d7afe0b38242ff4851fb32a6215f" id="r_ab129d7afe0b38242ff4851fb32a6215f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#ab129d7afe0b38242ff4851fb32a6215f">get_col</a> () const</td></tr>
<tr class="memdesc:ab129d7afe0b38242ff4851fb32a6215f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hardware grid column specifying the top-left corner of the logical tile on which this patch lives.  <br /></td></tr>
<tr class="separator:ab129d7afe0b38242ff4851fb32a6215f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b341cf782fe323d38e58b0545163a3f" id="r_a5b341cf782fe323d38e58b0545163a3f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a5b341cf782fe323d38e58b0545163a3f">get_parity_check_matrix</a> () const</td></tr>
<tr class="memdesc:a5b341cf782fe323d38e58b0545163a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get parity check matrix.  <br /></td></tr>
<tr class="separator:a5b341cf782fe323d38e58b0545163a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d06a54e0dad87ed48de4bcc0c4cc8b" id="r_a89d06a54e0dad87ed48de4bcc0c4cc8b"><td class="memItemLeft" align="right" valign="top">const std::map&lt; unsigned int, unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a89d06a54e0dad87ed48de4bcc0c4cc8b">get_qsite_to_index</a> () const</td></tr>
<tr class="memdesc:a89d06a54e0dad87ed48de4bcc0c4cc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get map from qsite (grid array index) to parity check matrix column.  <br /></td></tr>
<tr class="separator:a89d06a54e0dad87ed48de4bcc0c4cc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aed3b9553e10a0d051bdef27cd9198" id="r_aa4aed3b9553e10a0d051bdef27cd9198"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#aa4aed3b9553e10a0d051bdef27cd9198">get_index_to_qsite</a> () const</td></tr>
<tr class="memdesc:aa4aed3b9553e10a0d051bdef27cd9198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector that maps parity check matrix column to qsite.  <br /></td></tr>
<tr class="separator:aa4aed3b9553e10a0d051bdef27cd9198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d1017f4cf11d9f9c7f0a7922a13006" id="r_ae3d1017f4cf11d9f9c7f0a7922a13006"><td class="memItemLeft" align="right" valign="top">std::set&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#ae3d1017f4cf11d9f9c7f0a7922a13006">occupied_sites</a> (bool just_data_qubits) const</td></tr>
<tr class="memdesc:ae3d1017f4cf11d9f9c7f0a7922a13006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a set of qsites occupied by the plaquettes of this patch.  <br /></td></tr>
<tr class="separator:ae3d1017f4cf11d9f9c7f0a7922a13006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c00081093c982d4f08828a9d18ecb95" id="r_a5c00081093c982d4f08828a9d18ecb95"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a5c00081093c982d4f08828a9d18ecb95">get_logical_operator_default_edge</a> (char type) const</td></tr>
<tr class="memdesc:a5c00081093c982d4f08828a9d18ecb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean vector representing the default-edge logical operator of given type.  <br /></td></tr>
<tr class="separator:a5c00081093c982d4f08828a9d18ecb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97dac5c0253b58e39ad64475a303c302" id="r_a97dac5c0253b58e39ad64475a303c302"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a97dac5c0253b58e39ad64475a303c302">get_logical_operator_opposite_edge</a> (char type) const</td></tr>
<tr class="memdesc:a97dac5c0253b58e39ad64475a303c302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a boolean vector representing the opposite-edge logical operator of given type.  <br /></td></tr>
<tr class="separator:a97dac5c0253b58e39ad64475a303c302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa160c64efa0d5ddd4d060831559d229" id="r_aaa160c64efa0d5ddd4d060831559d229"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#aaa160c64efa0d5ddd4d060831559d229">get_logical_operator</a> (char type, std::string_view edge_type) const</td></tr>
<tr class="memdesc:aaa160c64efa0d5ddd4d060831559d229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls get_logical_operator_default_edge or get_logical_operator_opposite_edge depending on given edge_type.  <br /></td></tr>
<tr class="separator:aaa160c64efa0d5ddd4d060831559d229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90018403247daf8c08d5dd108aa3bdc9" id="r_a90018403247daf8c08d5dd108aa3bdc9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a90018403247daf8c08d5dd108aa3bdc9">get_logical_deformation_qsites</a> (char type) const</td></tr>
<tr class="memdesc:a90018403247daf8c08d5dd108aa3bdc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing qsites representing deformations that have been made to the default-edge logical operator of given type.  <br /></td></tr>
<tr class="separator:a90018403247daf8c08d5dd108aa3bdc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec397b6f218c6dc2fbb21edfd533a2df" id="r_aec397b6f218c6dc2fbb21edfd533a2df"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#aec397b6f218c6dc2fbb21edfd533a2df">get_logical_deformation_between_edges</a> (char type) const</td></tr>
<tr class="memdesc:aec397b6f218c6dc2fbb21edfd533a2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the syndrome measurement qsites required to deform the default-edge logical operator of given type into the corresponding opposite-edge logical operator.  <br /></td></tr>
<tr class="separator:aec397b6f218c6dc2fbb21edfd533a2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37ad24131ca4e9de881c8f138abe60c" id="r_ab37ad24131ca4e9de881c8f138abe60c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#ab37ad24131ca4e9de881c8f138abe60c">get_logical_deformation_operator_movement</a> (char type, int n, const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid)</td></tr>
<tr class="memdesc:ab37ad24131ca4e9de881c8f138abe60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the syndrome measurement qsites required to move the default-edge logical operator of given type by n columns or rows.  <br /></td></tr>
<tr class="separator:ab37ad24131ca4e9de881c8f138abe60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e00b4ac3e866fa575728166be39df5" id="r_a03e00b4ac3e866fa575728166be39df5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a03e00b4ac3e866fa575728166be39df5">canonical_arrangement</a> () const</td></tr>
<tr class="memdesc:a03e00b4ac3e866fa575728166be39df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if the patch is in a canonical stabilizer arrangement (see Fig. 2 of TISCC paper), and False otherwise.  <br /></td></tr>
<tr class="separator:a03e00b4ac3e866fa575728166be39df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c70aa12d07fb39ed286e092d2048617" id="r_a8c70aa12d07fb39ed286e092d2048617"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a8c70aa12d07fb39ed286e092d2048617">xz_swap_tracker</a> () const</td></tr>
<tr class="memdesc:a8c70aa12d07fb39ed286e092d2048617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if xz_swap has been applied to this patch and False otherwise.  <br /></td></tr>
<tr class="separator:a8c70aa12d07fb39ed286e092d2048617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225c873aa85090df793a5325af3683c7" id="r_a225c873aa85090df793a5325af3683c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a225c873aa85090df793a5325af3683c7">flipped_tracker</a> () const</td></tr>
<tr class="memdesc:a225c873aa85090df793a5325af3683c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if flip_patch has been applied to this patch and False otherwise.  <br /></td></tr>
<tr class="separator:a225c873aa85090df793a5325af3683c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3ae3cf4a96691050e3779379094235" id="r_a7d3ae3cf4a96691050e3779379094235"><td class="memItemLeft" align="right" valign="top"><a id="a7d3ae3cf4a96691050e3779379094235" name="a7d3ae3cf4a96691050e3779379094235"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_stabilizers</b> () const</td></tr>
<tr class="memdesc:a7d3ae3cf4a96691050e3779379094235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out some details of the stabilizers stored by this patch. <br /></td></tr>
<tr class="separator:a7d3ae3cf4a96691050e3779379094235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d51da95d287b4c7c33ab245c0dc4ef" id="r_a11d51da95d287b4c7c33ab245c0dc4ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a11d51da95d287b4c7c33ab245c0dc4ef">print_parity_check_matrix</a> () const</td></tr>
<tr class="memdesc:a11d51da95d287b4c7c33ab245c0dc4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out the parity check matrix stored by this patch and some ancillary data.  <br /></td></tr>
<tr class="separator:a11d51da95d287b4c7c33ab245c0dc4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac622c861692d14c282d5a4d7a541d6b5" id="r_ac622c861692d14c282d5a4d7a541d6b5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#ac622c861692d14c282d5a4d7a541d6b5">idle</a> (unsigned int cycles, const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master, double time)</td></tr>
<tr class="memdesc:ac622c861692d14c282d5a4d7a541d6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the hardware circuit for a logical Idle operation (which is a specified number of cycles of syndrome extraction).  <br /></td></tr>
<tr class="separator:ac622c861692d14c282d5a4d7a541d6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e884d65fa0aa5203f2a0bfab56f272" id="r_a79e884d65fa0aa5203f2a0bfab56f272"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a79e884d65fa0aa5203f2a0bfab56f272">transversal_op</a> (const std::string &amp;op, const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master, double time)</td></tr>
<tr class="memdesc:a79e884d65fa0aa5203f2a0bfab56f272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the hardware circuit for a given transversal operation (acts on all data qubits of the patch).  <br /></td></tr>
<tr class="separator:a79e884d65fa0aa5203f2a0bfab56f272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad867edcc282dc91542723bf58b82672a" id="r_ad867edcc282dc91542723bf58b82672a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#ad867edcc282dc91542723bf58b82672a">apply_pauli</a> (char pauli, const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master, double time)</td></tr>
<tr class="memdesc:ad867edcc282dc91542723bf58b82672a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the hardware circuit for the application of a given logical Pauli operator.  <br /></td></tr>
<tr class="separator:ad867edcc282dc91542723bf58b82672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabff6a1a8c135b23089d05b162d8d297" id="r_aabff6a1a8c135b23089d05b162d8d297"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#aabff6a1a8c135b23089d05b162d8d297">inject_state</a> (char label, const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master, double time)</td></tr>
<tr class="memdesc:aabff6a1a8c135b23089d05b162d8d297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a hardware circuit preparing the data qubits for state injection (the state is encoded upon a subsequent Idle operation).  <br /></td></tr>
<tr class="separator:aabff6a1a8c135b23089d05b162d8d297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287aca5389ad91b10ec61e3a8fb95ae2" id="r_a287aca5389ad91b10ec61e3a8fb95ae2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a287aca5389ad91b10ec61e3a8fb95ae2">swap_left</a> (<a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master, double time)</td></tr>
<tr class="memdesc:a287aca5389ad91b10ec61e3a8fb95ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the hardware circuit for the Swap Left operation (see Fig. 4 of the TISCC paper).  <br /></td></tr>
<tr class="separator:a287aca5389ad91b10ec61e3a8fb95ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274ffd4ead94d8b5020c7487d2e5bc8a" id="r_a274ffd4ead94d8b5020c7487d2e5bc8a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a274ffd4ead94d8b5020c7487d2e5bc8a">move_right</a> (unsigned int cycles, <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> *&amp;lq_extended, <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> *&amp;lq_contracted, <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master, double time)</td></tr>
<tr class="memdesc:a274ffd4ead94d8b5020c7487d2e5bc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the hardware circuit for the Move Right operation (see Fig. 4 of the TISCC paper).  <br /></td></tr>
<tr class="separator:a274ffd4ead94d8b5020c7487d2e5bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a52c5332203217882023ee42f0c434b" id="r_a4a52c5332203217882023ee42f0c434b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a4a52c5332203217882023ee42f0c434b">get_merged_lq</a> (<a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> &amp;lq2, <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid)</td></tr>
<tr class="memdesc:a4a52c5332203217882023ee42f0c434b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a logical qubit that represents the merged product of this qubit with an input one.  <br /></td></tr>
<tr class="separator:a4a52c5332203217882023ee42f0c434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaf6d63d14128a68d24c7e0e7c68e57" id="r_a5eaf6d63d14128a68d24c7e0e7c68e57"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a5eaf6d63d14128a68d24c7e0e7c68e57">merge</a> (unsigned int cycles, const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master, double time)</td></tr>
<tr class="memdesc:a5eaf6d63d14128a68d24c7e0e7c68e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the hardware circuit for a merge operation.  <br /></td></tr>
<tr class="separator:a5eaf6d63d14128a68d24c7e0e7c68e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2c0ac011986f5629195b485e5d9cb6" id="r_ace2c0ac011986f5629195b485e5d9cb6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#ace2c0ac011986f5629195b485e5d9cb6">split</a> (<a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master, double time)</td></tr>
<tr class="memdesc:ace2c0ac011986f5629195b485e5d9cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the hardware circuit for a split operation.  <br /></td></tr>
<tr class="separator:ace2c0ac011986f5629195b485e5d9cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a41d9aa022a493786142b56c707e019" id="r_a8a41d9aa022a493786142b56c707e019"><td class="memItemLeft" align="right" valign="top">std::set&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a8a41d9aa022a493786142b56c707e019">get_strip</a> (<a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> &amp;lq1, <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> &amp;lq2)</td></tr>
<tr class="memdesc:a8a41d9aa022a493786142b56c707e019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns the set of data qsites from this patch that are not occupied by two other input patches.  <br /></td></tr>
<tr class="separator:a8a41d9aa022a493786142b56c707e019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69de438a0adb82c276f2d5c69d2cc387" id="r_a69de438a0adb82c276f2d5c69d2cc387"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a69de438a0adb82c276f2d5c69d2cc387">xz_swap</a> (const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid)</td></tr>
<tr class="memdesc:a69de438a0adb82c276f2d5c69d2cc387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap roles of X and Z operators for this patch.  <br /></td></tr>
<tr class="separator:a69de438a0adb82c276f2d5c69d2cc387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4ecf0a618a8ebe9d921a6e0bd30026" id="r_a7c4ecf0a618a8ebe9d921a6e0bd30026"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a7c4ecf0a618a8ebe9d921a6e0bd30026">add_stabilizer</a> (unsigned int row, unsigned int col, char shape, char type, <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master, double time, bool debug)</td></tr>
<tr class="memdesc:a7c4ecf0a618a8ebe9d921a6e0bd30026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new boundary stabilizer plaquette and handles the consequences of doing so (typically used in corner movement).  <br /></td></tr>
<tr class="separator:a7c4ecf0a618a8ebe9d921a6e0bd30026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f6a06a3e3151e6b49c7c3386dd56a8" id="r_a76f6a06a3e3151e6b49c7c3386dd56a8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a76f6a06a3e3151e6b49c7c3386dd56a8">extend_logical_operator_clockwise</a> (char type, std::string_view edge_type, unsigned int weight_to_add, bool stop_at_patch_corner, <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master, double time, bool debug)</td></tr>
<tr class="memdesc:a76f6a06a3e3151e6b49c7c3386dd56a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a corner movement by adding a specified weight to a specified logical operator.  <br /></td></tr>
<tr class="separator:a76f6a06a3e3151e6b49c7c3386dd56a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5043bb494279ddfe0b0c7e816b0491d" id="r_ae5043bb494279ddfe0b0c7e816b0491d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#ae5043bb494279ddfe0b0c7e816b0491d">flip_patch</a> (<a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master, float time, bool compile_ops, bool debug)</td></tr>
<tr class="memdesc:ae5043bb494279ddfe0b0c7e816b0491d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A series of corner movements with the resulting stabilizer arrangement the same as if we flipped the patch upside down and then applied xz_swap.  <br /></td></tr>
<tr class="separator:ae5043bb494279ddfe0b0c7e816b0491d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db433573ea37f7dc9ea16ccf4a7349b" id="r_a7db433573ea37f7dc9ea16ccf4a7349b"><td class="memItemLeft" align="right" valign="top"><a id="a7db433573ea37f7dc9ea16ccf4a7349b" name="a7db433573ea37f7dc9ea16ccf4a7349b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset_stabilizer_circuit_patterns</b> ()</td></tr>
<tr class="memdesc:a7db433573ea37f7dc9ea16ccf4a7349b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets stabilizer circuit patterns to default values. <br /></td></tr>
<tr class="separator:a7db433573ea37f7dc9ea16ccf4a7349b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded516bc910dd6d5bc3e1da30480b0df" id="r_aded516bc910dd6d5bc3e1da30480b0df"><td class="memItemLeft" align="right" valign="top"><a id="aded516bc910dd6d5bc3e1da30480b0df" name="aded516bc910dd6d5bc3e1da30480b0df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap_stabilizer_circuit_patterns</b> ()</td></tr>
<tr class="memdesc:aded516bc910dd6d5bc3e1da30480b0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles all stabilizer circuit patterns. <br /></td></tr>
<tr class="separator:aded516bc910dd6d5bc3e1da30480b0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82935dc65299a56cbbc2255531103c3" id="r_ae82935dc65299a56cbbc2255531103c3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned int, char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#ae82935dc65299a56cbbc2255531103c3">binary_operator_to_qsites</a> (const std::vector&lt; bool &gt; &amp;binary_rep)</td></tr>
<tr class="memdesc:ae82935dc65299a56cbbc2255531103c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform operators from binary representation to pair&lt;qsite unsigned int, Pauli char&gt;  <br /></td></tr>
<tr class="separator:ae82935dc65299a56cbbc2255531103c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7859ee6f0ff183acf3f79cf29fd58a" id="r_aeb7859ee6f0ff183acf3f79cf29fd58a"><td class="memItemLeft" align="right" valign="top"><a id="aeb7859ee6f0ff183acf3f79cf29fd58a" name="aeb7859ee6f0ff183acf3f79cf29fd58a"></a>
std::vector&lt; std::pair&lt; unsigned int, char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>syndrome_measurement_qsites</b> ()</td></tr>
<tr class="memdesc:aeb7859ee6f0ff183acf3f79cf29fd58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain pair&lt;qsite unsigned int, Pauli char&gt; for each stabilizer measure qubit for the purpose of labeling on the grid. <br /></td></tr>
<tr class="separator:aeb7859ee6f0ff183acf3f79cf29fd58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af79f867b58e2682636e81b839a82f409" id="r_af79f867b58e2682636e81b839a82f409"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#af79f867b58e2682636e81b839a82f409">bin_dot_prod_mod_2</a> (const std::vector&lt; bool &gt; &amp;v1, const std::vector&lt; bool &gt; v2)</td></tr>
<tr class="memdesc:af79f867b58e2682636e81b839a82f409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product mod 2 of two binary vectors.  <br /></td></tr>
<tr class="separator:af79f867b58e2682636e81b839a82f409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0816ab857b409eb757ef255e336ddee6" id="r_a0816ab857b409eb757ef255e336ddee6"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::vector&lt; bool &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a0816ab857b409eb757ef255e336ddee6">operator_product_binary_format</a> (const std::vector&lt; bool &gt; &amp;v1, const std::vector&lt; bool &gt; v2)</td></tr>
<tr class="memdesc:a0816ab857b409eb757ef255e336ddee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the product of two operators expressed in binary symplectic format.  <br /></td></tr>
<tr class="separator:a0816ab857b409eb757ef255e336ddee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001f1a2bfeb8ca3f454e7588678f2bc0" id="r_a001f1a2bfeb8ca3f454e7588678f2bc0"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a001f1a2bfeb8ca3f454e7588678f2bc0">symplectic_transform</a> (const std::vector&lt; bool &gt; &amp;v)</td></tr>
<tr class="memdesc:a001f1a2bfeb8ca3f454e7588678f2bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symplectic transform of a binary symplectic vector.  <br /></td></tr>
<tr class="separator:a001f1a2bfeb8ca3f454e7588678f2bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723e465dc1227dbbf9dde861ee751a2d" id="r_a723e465dc1227dbbf9dde861ee751a2d"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a723e465dc1227dbbf9dde861ee751a2d">hamming_weight</a> (const std::vector&lt; bool &gt; &amp;v)</td></tr>
<tr class="memdesc:a723e465dc1227dbbf9dde861ee751a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Hamming weight of a given binary vector.  <br /></td></tr>
<tr class="separator:a723e465dc1227dbbf9dde861ee751a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96502174f44d6ada6d802f3ed2a661c3" id="r_a96502174f44d6ada6d802f3ed2a661c3"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::string, std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a96502174f44d6ada6d802f3ed2a661c3">binary_operator_to_pauli_string</a> (const std::vector&lt; bool &gt; &amp;binary_rep)</td></tr>
<tr class="memdesc:a96502174f44d6ada6d802f3ed2a661c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform operators from binary symplectic to string representation while tracking phase e.g. 11000101 = Z(ZX)IX = i*ZYIX.  <br /></td></tr>
<tr class="separator:a96502174f44d6ada6d802f3ed2a661c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42053ea5aff93523737b6bac4aa9de6e" id="r_a42053ea5aff93523737b6bac4aa9de6e"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::vector&lt; bool &gt;, std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html#a42053ea5aff93523737b6bac4aa9de6e">pauli_string_to_binary_operator</a> (const std::string &amp;pauli_string)</td></tr>
<tr class="memdesc:a42053ea5aff93523737b6bac4aa9de6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform operators from string to binary symplectic representation, tracking phase e.g. ZYIX -&gt; -i*(11000101)  <br /></td></tr>
<tr class="separator:a42053ea5aff93523737b6bac4aa9de6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8ccb0abe9346c29c6ec1d536f8676fcc" id="r_a8ccb0abe9346c29c6ec1d536f8676fcc"><td class="memItemLeft" align="right" valign="top"><a id="a8ccb0abe9346c29c6ec1d536f8676fcc" name="a8ccb0abe9346c29c6ec1d536f8676fcc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init_stabilizers</b> (unsigned int dx, unsigned int dz, unsigned int row, unsigned int col, <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid)</td></tr>
<tr class="separator:a8ccb0abe9346c29c6ec1d536f8676fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791e17fe2a330b2c57b4d412c508a2c1" id="r_a791e17fe2a330b2c57b4d412c508a2c1"><td class="memItemLeft" align="right" valign="top"><a id="a791e17fe2a330b2c57b4d412c508a2c1" name="a791e17fe2a330b2c57b4d412c508a2c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>test_stabilizers</b> ()</td></tr>
<tr class="separator:a791e17fe2a330b2c57b4d412c508a2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872300c49f70997d8ec4a63d15157de1" id="r_a872300c49f70997d8ec4a63d15157de1"><td class="memItemLeft" align="right" valign="top"><a id="a872300c49f70997d8ec4a63d15157de1" name="a872300c49f70997d8ec4a63d15157de1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init_circuits</b> ()</td></tr>
<tr class="separator:a872300c49f70997d8ec4a63d15157de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d94e2a372abf79b5364eaa80c595550" id="r_a8d94e2a372abf79b5364eaa80c595550"><td class="memItemLeft" align="right" valign="top"><a id="a8d94e2a372abf79b5364eaa80c595550" name="a8d94e2a372abf79b5364eaa80c595550"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>construct_parity_check_matrix</b> (const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid)</td></tr>
<tr class="separator:a8d94e2a372abf79b5364eaa80c595550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5d736283aab8f31f61b6be3d998fa3" id="r_abc5d736283aab8f31f61b6be3d998fa3"><td class="memItemLeft" align="right" valign="top"><a id="abc5d736283aab8f31f61b6be3d998fa3" name="abc5d736283aab8f31f61b6be3d998fa3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>validity_parity_check_matrix</b> () const</td></tr>
<tr class="separator:abc5d736283aab8f31f61b6be3d998fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b064aed607ff441025a3fcb4275e291" id="r_a2b064aed607ff441025a3fcb4275e291"><td class="memItemLeft" align="right" valign="top"><a id="a2b064aed607ff441025a3fcb4275e291" name="a2b064aed607ff441025a3fcb4275e291"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>recalculate_code_distance</b> ()</td></tr>
<tr class="separator:a2b064aed607ff441025a3fcb4275e291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eb149a1100de2c98095096605942a9" id="r_ab1eb149a1100de2c98095096605942a9"><td class="memItemLeft" align="right" valign="top"><a id="ab1eb149a1100de2c98095096605942a9" name="ab1eb149a1100de2c98095096605942a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_logical_deformation_qsites</b> (char type, unsigned int qsite)</td></tr>
<tr class="separator:ab1eb149a1100de2c98095096605942a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4ed23edda11e028e2abe31c662e9c5" id="r_a3d4ed23edda11e028e2abe31c662e9c5"><td class="memItemLeft" align="right" valign="top"><a id="a3d4ed23edda11e028e2abe31c662e9c5" name="a3d4ed23edda11e028e2abe31c662e9c5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>apply_instruction</b> (const <a class="el" href="class_t_i_s_c_c_1_1_instruction.html">Instruction</a> &amp;instr, <a class="el" href="class_t_i_s_c_c_1_1_plaquette.html">Plaquette</a> &amp;p, double time, unsigned int step, const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master)</td></tr>
<tr class="separator:a3d4ed23edda11e028e2abe31c662e9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5c2c139684c94abbd4113120025f61" id="r_a3b5c2c139684c94abbd4113120025f61"><td class="memItemLeft" align="right" valign="top"><a id="a3b5c2c139684c94abbd4113120025f61" name="a3b5c2c139684c94abbd4113120025f61"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>translate_patch</b> (int s, int e, <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;grid, std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;hw_master, double time)</td></tr>
<tr class="separator:a3b5c2c139684c94abbd4113120025f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad811a12a1cf0256b727f069cfb5bd4fe" id="r_ad811a12a1cf0256b727f069cfb5bd4fe"><td class="memItemLeft" align="right" valign="top"><a id="ad811a12a1cf0256b727f069cfb5bd4fe" name="ad811a12a1cf0256b727f069cfb5bd4fe"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>dx_</b></td></tr>
<tr class="separator:ad811a12a1cf0256b727f069cfb5bd4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501496f9edfe3affbcc954a6c91eb06a" id="r_a501496f9edfe3affbcc954a6c91eb06a"><td class="memItemLeft" align="right" valign="top"><a id="a501496f9edfe3affbcc954a6c91eb06a" name="a501496f9edfe3affbcc954a6c91eb06a"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>dx_init_</b></td></tr>
<tr class="separator:a501496f9edfe3affbcc954a6c91eb06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9f5951cba7b37ee2a39ca24be31fe0" id="r_a0d9f5951cba7b37ee2a39ca24be31fe0"><td class="memItemLeft" align="right" valign="top"><a id="a0d9f5951cba7b37ee2a39ca24be31fe0" name="a0d9f5951cba7b37ee2a39ca24be31fe0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>dz_</b></td></tr>
<tr class="separator:a0d9f5951cba7b37ee2a39ca24be31fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25aa8d45b532d1ccb6adf879527a7e72" id="r_a25aa8d45b532d1ccb6adf879527a7e72"><td class="memItemLeft" align="right" valign="top"><a id="a25aa8d45b532d1ccb6adf879527a7e72" name="a25aa8d45b532d1ccb6adf879527a7e72"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>dz_init_</b></td></tr>
<tr class="separator:a25aa8d45b532d1ccb6adf879527a7e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee826cb6fd332b12f3c9ff0fb5b7dda4" id="r_aee826cb6fd332b12f3c9ff0fb5b7dda4"><td class="memItemLeft" align="right" valign="top"><a id="aee826cb6fd332b12f3c9ff0fb5b7dda4" name="aee826cb6fd332b12f3c9ff0fb5b7dda4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>row_</b></td></tr>
<tr class="separator:aee826cb6fd332b12f3c9ff0fb5b7dda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad460ac1d65757188b73e8de60e5cdf60" id="r_ad460ac1d65757188b73e8de60e5cdf60"><td class="memItemLeft" align="right" valign="top"><a id="ad460ac1d65757188b73e8de60e5cdf60" name="ad460ac1d65757188b73e8de60e5cdf60"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>col_</b></td></tr>
<tr class="separator:ad460ac1d65757188b73e8de60e5cdf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad62aa89204f54cbe4f78c50f4397926" id="r_aad62aa89204f54cbe4f78c50f4397926"><td class="memItemLeft" align="right" valign="top"><a id="aad62aa89204f54cbe4f78c50f4397926" name="aad62aa89204f54cbe4f78c50f4397926"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>canonical_arrangement_</b></td></tr>
<tr class="separator:aad62aa89204f54cbe4f78c50f4397926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adc80ab05ee0266fe995ca1d1def2de" id="r_a1adc80ab05ee0266fe995ca1d1def2de"><td class="memItemLeft" align="right" valign="top"><a id="a1adc80ab05ee0266fe995ca1d1def2de" name="a1adc80ab05ee0266fe995ca1d1def2de"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>xz_swap_tracker_</b></td></tr>
<tr class="separator:a1adc80ab05ee0266fe995ca1d1def2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099f86b3ad8dc7ad0b9f78c65ec26d55" id="r_a099f86b3ad8dc7ad0b9f78c65ec26d55"><td class="memItemLeft" align="right" valign="top"><a id="a099f86b3ad8dc7ad0b9f78c65ec26d55" name="a099f86b3ad8dc7ad0b9f78c65ec26d55"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>flipped_tracker_</b></td></tr>
<tr class="separator:a099f86b3ad8dc7ad0b9f78c65ec26d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15b73cd2e1a51cab94df43a9acf652c" id="r_ad15b73cd2e1a51cab94df43a9acf652c"><td class="memItemLeft" align="right" valign="top"><a id="ad15b73cd2e1a51cab94df43a9acf652c" name="ad15b73cd2e1a51cab94df43a9acf652c"></a>
<a class="el" href="class_t_i_s_c_c_1_1_hardware_model.html">HardwareModel</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TI_model</b></td></tr>
<tr class="separator:ad15b73cd2e1a51cab94df43a9acf652c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9ea1fe77d1acceabac527e56bb282f" id="r_a9e9ea1fe77d1acceabac527e56bb282f"><td class="memItemLeft" align="right" valign="top"><a id="a9e9ea1fe77d1acceabac527e56bb282f" name="a9e9ea1fe77d1acceabac527e56bb282f"></a>
std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_plaquette.html">Plaquette</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>x_plaquettes</b></td></tr>
<tr class="separator:a9e9ea1fe77d1acceabac527e56bb282f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325bc17402046e7b77991688761b32c9" id="r_a325bc17402046e7b77991688761b32c9"><td class="memItemLeft" align="right" valign="top"><a id="a325bc17402046e7b77991688761b32c9" name="a325bc17402046e7b77991688761b32c9"></a>
std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_plaquette.html">Plaquette</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>z_plaquettes</b></td></tr>
<tr class="separator:a325bc17402046e7b77991688761b32c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ecb2da5c0624c7f09ed7e38d3df5c2" id="r_ad0ecb2da5c0624c7f09ed7e38d3df5c2"><td class="memItemLeft" align="right" valign="top"><a id="ad0ecb2da5c0624c7f09ed7e38d3df5c2" name="ad0ecb2da5c0624c7f09ed7e38d3df5c2"></a>
std::vector&lt; std::vector&lt; bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parity_check_matrix</b></td></tr>
<tr class="separator:ad0ecb2da5c0624c7f09ed7e38d3df5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2551f10c77cdb0a9fe24ed8385085f2d" id="r_a2551f10c77cdb0a9fe24ed8385085f2d"><td class="memItemLeft" align="right" valign="top"><a id="a2551f10c77cdb0a9fe24ed8385085f2d" name="a2551f10c77cdb0a9fe24ed8385085f2d"></a>
std::map&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>qsite_to_index</b></td></tr>
<tr class="separator:a2551f10c77cdb0a9fe24ed8385085f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc6262e42de020c81015fcae9de2be3" id="r_a4fc6262e42de020c81015fcae9de2be3"><td class="memItemLeft" align="right" valign="top"><a id="a4fc6262e42de020c81015fcae9de2be3" name="a4fc6262e42de020c81015fcae9de2be3"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>index_to_qsite</b></td></tr>
<tr class="separator:a4fc6262e42de020c81015fcae9de2be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab032821add1731207fa0b6eae5d37611" id="r_ab032821add1731207fa0b6eae5d37611"><td class="memItemLeft" align="right" valign="top"><a id="ab032821add1731207fa0b6eae5d37611" name="ab032821add1731207fa0b6eae5d37611"></a>
std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_instruction.html">Instruction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Z_Circuit_Z_Type</b></td></tr>
<tr class="separator:ab032821add1731207fa0b6eae5d37611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4715c685cc53f4ea8879cd6ec67d7c85" id="r_a4715c685cc53f4ea8879cd6ec67d7c85"><td class="memItemLeft" align="right" valign="top"><a id="a4715c685cc53f4ea8879cd6ec67d7c85" name="a4715c685cc53f4ea8879cd6ec67d7c85"></a>
std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_instruction.html">Instruction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>X_Circuit_N_Type</b></td></tr>
<tr class="separator:a4715c685cc53f4ea8879cd6ec67d7c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119cf09bf2515d658f84c8786fb8e577" id="r_a119cf09bf2515d658f84c8786fb8e577"><td class="memItemLeft" align="right" valign="top"><a id="a119cf09bf2515d658f84c8786fb8e577" name="a119cf09bf2515d658f84c8786fb8e577"></a>
std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_instruction.html">Instruction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Z_Circuit_N_Type</b></td></tr>
<tr class="separator:a119cf09bf2515d658f84c8786fb8e577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1766c00bc3d66389924a3af064adb294" id="r_a1766c00bc3d66389924a3af064adb294"><td class="memItemLeft" align="right" valign="top"><a id="a1766c00bc3d66389924a3af064adb294" name="a1766c00bc3d66389924a3af064adb294"></a>
std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_instruction.html">Instruction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>X_Circuit_Z_Type</b></td></tr>
<tr class="separator:a1766c00bc3d66389924a3af064adb294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1991e085b82383fbf59e9fae4fca7abb" id="r_a1991e085b82383fbf59e9fae4fca7abb"><td class="memItemLeft" align="right" valign="top"><a id="a1991e085b82383fbf59e9fae4fca7abb" name="a1991e085b82383fbf59e9fae4fca7abb"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>x_deformation_qsites</b></td></tr>
<tr class="separator:a1991e085b82383fbf59e9fae4fca7abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409c7638bf57bf6cefee5b8789e29961" id="r_a409c7638bf57bf6cefee5b8789e29961"><td class="memItemLeft" align="right" valign="top"><a id="a409c7638bf57bf6cefee5b8789e29961" name="a409c7638bf57bf6cefee5b8789e29961"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>z_deformation_qsites</b></td></tr>
<tr class="separator:a409c7638bf57bf6cefee5b8789e29961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8796e07ba643edc2deba60fd80c76e70" id="r_a8796e07ba643edc2deba60fd80c76e70"><td class="memItemLeft" align="right" valign="top"><a id="a8796e07ba643edc2deba60fd80c76e70" name="a8796e07ba643edc2deba60fd80c76e70"></a>
<a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>lq1</b></td></tr>
<tr class="separator:a8796e07ba643edc2deba60fd80c76e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06303b6ba8bfcbf306e2997f6d418c5" id="r_ac06303b6ba8bfcbf306e2997f6d418c5"><td class="memItemLeft" align="right" valign="top"><a id="ac06303b6ba8bfcbf306e2997f6d418c5" name="ac06303b6ba8bfcbf306e2997f6d418c5"></a>
<a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>lq2</b></td></tr>
<tr class="separator:ac06303b6ba8bfcbf306e2997f6d418c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and to generate circuits for a set of primitive patch operations. </p>
<p>Designed to be compatible with grid-like hardware architectures where data and syndrome measurement qubits, even if mobile, have dedicated "home" qsites. Its construction on the hardware grid assumes the definition for logical tile specified in the TISCC paper. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9e79d6c719e33b9465e1b791f69421a8" name="a9e79d6c719e33b9465e1b791f69421a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e79d6c719e33b9465e1b791f69421a8">&#9670;&#160;</a></span>LogicalQubit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TISCC::LogicalQubit::LogicalQubit </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html" title="Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and t...">LogicalQubit</a> class. </p>
<p>Requests Plaquettes from <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> and constructs other members such as the parity check matrix and syndrome extraction circuits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>The initial x code distance (width) of the surface code patch. </td></tr>
    <tr><td class="paramname">dz</td><td>The initial z code distance (height) of the surface code patch. </td></tr>
    <tr><td class="paramname">row</td><td>The hardware grid row specifying the top-left corner of the logical tile on which this patch lives. </td></tr>
    <tr><td class="paramname">col</td><td>The hardware grid column specifying the top-left corner of the logical tile on which this patch lives. </td></tr>
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> from which Plaquettes should be requested for this <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html" title="Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and t...">LogicalQubit</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7c4ecf0a618a8ebe9d921a6e0bd30026" name="a7c4ecf0a618a8ebe9d921a6e0bd30026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4ecf0a618a8ebe9d921a6e0bd30026">&#9670;&#160;</a></span>add_stabilizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TISCC::LogicalQubit::add_stabilizer </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hw_master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new boundary stabilizer plaquette and handles the consequences of doing so (typically used in corner movement). </p>
<p>Removes anti-commuting stabilizers, updates logical operators, and measures/prepares corner qubits as needed. Checks validity of the final parity check matrix. A subsequent Idle operation is needed to actually measure the newly added stabilizer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The hardware grid row at which the new stabilizer plaquette is "pinned". </td></tr>
    <tr><td class="paramname">col</td><td>The hardware grid col at which the new stabilizer plaquette is "pinned". </td></tr>
    <tr><td class="paramname">shape</td><td>The shape of the added stabilizer. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the added stabilizer. </td></tr>
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object to obtain the new stabilizer from. </td></tr>
    <tr><td class="paramname">hw_master</td><td>The vector of hardware instructions to append any needed hardware operations to. </td></tr>
    <tr><td class="paramname">time</td><td>The nominal time at which this operation begins. </td></tr>
    <tr><td class="paramname">debug</td><td>A boolean to trigger debugging output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nominal time at which this operation ends. </dd></dl>

</div>
</div>
<a id="ad867edcc282dc91542723bf58b82672a" name="ad867edcc282dc91542723bf58b82672a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad867edcc282dc91542723bf58b82672a">&#9670;&#160;</a></span>apply_pauli()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TISCC::LogicalQubit::apply_pauli </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pauli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hw_master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the hardware circuit for the application of a given logical Pauli operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pauli</td><td>Operator label. Options: 'X', 'Y', 'Z'. </td></tr>
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object for reference. </td></tr>
    <tr><td class="paramname">hw_master</td><td>The vector of hardware instructions to append this operation to. </td></tr>
    <tr><td class="paramname">time</td><td>The nominal time at which this operation begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nominal time at which this operation ends. </dd></dl>

</div>
</div>
<a id="af79f867b58e2682636e81b839a82f409" name="af79f867b58e2682636e81b839a82f409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79f867b58e2682636e81b839a82f409">&#9670;&#160;</a></span>bin_dot_prod_mod_2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TISCC::LogicalQubit::bin_dot_prod_mod_2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product mod 2 of two binary vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>A Boolean variable representing the result. </dd></dl>

</div>
</div>
<a id="a96502174f44d6ada6d802f3ed2a661c3" name="a96502174f44d6ada6d802f3ed2a661c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96502174f44d6ada6d802f3ed2a661c3">&#9670;&#160;</a></span>binary_operator_to_pauli_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::complex&lt; double &gt; &gt; TISCC::LogicalQubit::binary_operator_to_pauli_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>binary_rep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform operators from binary symplectic to string representation while tracking phase e.g. 11000101 = Z(ZX)IX = i*ZYIX. </p>
<dl class="section return"><dt>Returns</dt><dd>A pair with the operator string on one hand and a phase on the other. </dd></dl>

</div>
</div>
<a id="ae82935dc65299a56cbbc2255531103c3" name="ae82935dc65299a56cbbc2255531103c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82935dc65299a56cbbc2255531103c3">&#9670;&#160;</a></span>binary_operator_to_qsites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned int, char &gt; &gt; TISCC::LogicalQubit::binary_operator_to_qsites </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>binary_rep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform operators from binary representation to pair&lt;qsite unsigned int, Pauli char&gt; </p>
<p>Note: this function will convert ZX directly to Y without tracking any phase. </p>

</div>
</div>
<a id="a03e00b4ac3e866fa575728166be39df5" name="a03e00b4ac3e866fa575728166be39df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e00b4ac3e866fa575728166be39df5">&#9670;&#160;</a></span>canonical_arrangement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TISCC::LogicalQubit::canonical_arrangement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if the patch is in a canonical stabilizer arrangement (see Fig. 2 of TISCC paper), and False otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the patch is in a canonical stabilizer arrangement (see Fig. 2 of TISCC paper), and False otherwise. </dd></dl>

</div>
</div>
<a id="a76f6a06a3e3151e6b49c7c3386dd56a8" name="a76f6a06a3e3151e6b49c7c3386dd56a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f6a06a3e3151e6b49c7c3386dd56a8">&#9670;&#160;</a></span>extend_logical_operator_clockwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TISCC::LogicalQubit::extend_logical_operator_clockwise </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>edge_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>weight_to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stop_at_patch_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hw_master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a corner movement by adding a specified weight to a specified logical operator. </p>
<p>Figures out which stabilizers to measure when extending a logical operator &lsquo;clockwise&rsquo; and calls add_stabilizer until the specified weight has been added. Warning: add_stabilizer will update the default-edge (rather than opposite-edge) logical operator that has support on the added stabilizer in ambiguous cases. <br  />
 This may cause unexpected results where the operator to be extended has support on a single qubit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of logical operator to extend ('X' or 'Z'). </td></tr>
    <tr><td class="paramname">edge_type</td><td>The edge_type of logical operator to extend ("default" or "opposite"). </td></tr>
    <tr><td class="paramname">weight_to_add</td><td>The (minimum) weight to add in extending the operator (will add stabilizers until the final added weight is at least this amount) </td></tr>
    <tr><td class="paramname">stop_at_patch_corner</td><td>Causes extension to stop if a patch corner is hit. </td></tr>
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object to obtain new stabilizers from. </td></tr>
    <tr><td class="paramname">hw_master</td><td>The vector of hardware instructions to append any needed hardware operations to. </td></tr>
    <tr><td class="paramname">time</td><td>The nominal time at which this operation begins. </td></tr>
    <tr><td class="paramname">debug</td><td>A boolean to trigger debugging output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nominal time at which this operation ends. </dd></dl>

</div>
</div>
<a id="ae5043bb494279ddfe0b0c7e816b0491d" name="ae5043bb494279ddfe0b0c7e816b0491d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5043bb494279ddfe0b0c7e816b0491d">&#9670;&#160;</a></span>flip_patch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TISCC::LogicalQubit::flip_patch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hw_master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compile_ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A series of corner movements with the resulting stabilizer arrangement the same as if we flipped the patch upside down and then applied xz_swap. </p>
<p>See Fig. 3 of the TISCC paper for details. Only implemented for patches in the standard and rotated arrangements. Works for all odd code distances and even code distances &gt;= 6. Needn't be used as a surface code operation in itself; can be used to transform the stabilizers of this <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html" title="Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and t...">LogicalQubit</a> to a flipped or rotated-flipped arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object to obtain new stabilizers from in corner movements. </td></tr>
    <tr><td class="paramname">hw_master</td><td>The vector of hardware instructions to append this operation to (depending on compile_ops). </td></tr>
    <tr><td class="paramname">time</td><td>The nominal time at which this operation begins. </td></tr>
    <tr><td class="paramname">compile_ops</td><td>A boolean specifying whether the hardware operations involved in Flip Patch should be added to the circuit. </td></tr>
    <tr><td class="paramname">debug</td><td>A boolean to trigger debugging output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nominal time at which this operation ends. </dd></dl>

</div>
</div>
<a id="a225c873aa85090df793a5325af3683c7" name="a225c873aa85090df793a5325af3683c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225c873aa85090df793a5325af3683c7">&#9670;&#160;</a></span>flipped_tracker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TISCC::LogicalQubit::flipped_tracker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if flip_patch has been applied to this patch and False otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>True if flip_patch has been applied to this patch and False otherwise. </dd></dl>

</div>
</div>
<a id="ab129d7afe0b38242ff4851fb32a6215f" name="ab129d7afe0b38242ff4851fb32a6215f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab129d7afe0b38242ff4851fb32a6215f">&#9670;&#160;</a></span>get_col()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TISCC::LogicalQubit::get_col </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get hardware grid column specifying the top-left corner of the logical tile on which this patch lives. </p>
<dl class="section return"><dt>Returns</dt><dd>Hardware grid column specifying the top-left corner of the logical tile on which this patch lives. </dd></dl>

</div>
</div>
<a id="af5efd62193536bce72fad7a2cdb48078" name="af5efd62193536bce72fad7a2cdb48078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5efd62193536bce72fad7a2cdb48078">&#9670;&#160;</a></span>get_dx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TISCC::LogicalQubit::get_dx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current x code distance. </p>
<dl class="section return"><dt>Returns</dt><dd>Current x code distance. </dd></dl>

</div>
</div>
<a id="aa97658e584b8fdf6de35d6e869e80992" name="aa97658e584b8fdf6de35d6e869e80992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97658e584b8fdf6de35d6e869e80992">&#9670;&#160;</a></span>get_dx_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TISCC::LogicalQubit::get_dx_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get initial x code distance. </p>
<dl class="section return"><dt>Returns</dt><dd>Initial x code distance. </dd></dl>

</div>
</div>
<a id="a59152c30cb3ec54734b4c9d9530f0d84" name="a59152c30cb3ec54734b4c9d9530f0d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59152c30cb3ec54734b4c9d9530f0d84">&#9670;&#160;</a></span>get_dz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TISCC::LogicalQubit::get_dz </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current z code distance. </p>
<dl class="section return"><dt>Returns</dt><dd>Current z code distance. </dd></dl>

</div>
</div>
<a id="ac2c9370ea8977bc77715ad6e126656c4" name="ac2c9370ea8977bc77715ad6e126656c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c9370ea8977bc77715ad6e126656c4">&#9670;&#160;</a></span>get_dz_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TISCC::LogicalQubit::get_dz_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get initial z code distance. </p>
<dl class="section return"><dt>Returns</dt><dd>Initial z code distance. </dd></dl>

</div>
</div>
<a id="aa4aed3b9553e10a0d051bdef27cd9198" name="aa4aed3b9553e10a0d051bdef27cd9198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4aed3b9553e10a0d051bdef27cd9198">&#9670;&#160;</a></span>get_index_to_qsite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned int &gt; &amp; TISCC::LogicalQubit::get_index_to_qsite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector that maps parity check matrix column to qsite. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to a vector that maps parity check matrix column to qsite. </dd></dl>

</div>
</div>
<a id="aec397b6f218c6dc2fbb21edfd533a2df" name="aec397b6f218c6dc2fbb21edfd533a2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec397b6f218c6dc2fbb21edfd533a2df">&#9670;&#160;</a></span>get_logical_deformation_between_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; TISCC::LogicalQubit::get_logical_deformation_between_edges </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector containing the syndrome measurement qsites required to deform the default-edge logical operator of given type into the corresponding opposite-edge logical operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Specifies either the X logical operator ('X') or the Z logical operator ('Z'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the syndrome measurement qsites required to deform the default-edge logical operator of given type into the corresponding opposite-edge logical operator. </dd></dl>

</div>
</div>
<a id="ab37ad24131ca4e9de881c8f138abe60c" name="ab37ad24131ca4e9de881c8f138abe60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37ad24131ca4e9de881c8f138abe60c">&#9670;&#160;</a></span>get_logical_deformation_operator_movement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; TISCC::LogicalQubit::get_logical_deformation_operator_movement </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector containing the syndrome measurement qsites required to move the default-edge logical operator of given type by n columns or rows. </p>
<p>Only valid for operators with support all on one column or all on one row. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Specifies either the X logical operator ('X') or the Z logical operator ('Z'). </td></tr>
    <tr><td class="paramname">n</td><td>Specifies the number of rows or columsn to shift the operator by. </td></tr>
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object for reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the syndrome measurement qsites required to move the default-edge logical operator of given type by n columns or rows. </dd></dl>

</div>
</div>
<a id="a90018403247daf8c08d5dd108aa3bdc9" name="a90018403247daf8c08d5dd108aa3bdc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90018403247daf8c08d5dd108aa3bdc9">&#9670;&#160;</a></span>get_logical_deformation_qsites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; TISCC::LogicalQubit::get_logical_deformation_qsites </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector containing qsites representing deformations that have been made to the default-edge logical operator of given type. </p>
<p>Primarily used to track logical operator deformations resulting from corner movements. In corner movements, newly-measured boundary stabilizers may anti-commute with logical operators and/or stabilizers, requiring the logical operators to be re-defined. TISCC also updates logical operator definitions when newly measured stabilizers overlap with them in order that they retain a minimal Pauli weight. Lastly, logical operators may be re-defined in the case that corner data qubits of a patch are measured out. All of this information must be incorporated into a sign update of the logical operator following the corner movement operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Specifies either the X logical operator deformation ('X') or the Z logical operator deformation ('Z'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing qsites representing deformations that have been made to the default-edge logical operator of given type. </dd></dl>

</div>
</div>
<a id="aaa160c64efa0d5ddd4d060831559d229" name="aaa160c64efa0d5ddd4d060831559d229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa160c64efa0d5ddd4d060831559d229">&#9670;&#160;</a></span>get_logical_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; TISCC::LogicalQubit::get_logical_operator </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>edge_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls get_logical_operator_default_edge or get_logical_operator_opposite_edge depending on given edge_type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Specifies either the X logical operator ('X') or the Z logical operator ('Z'). </td></tr>
    <tr><td class="paramname">edge_type</td><td>Specifies either the default-edge logical operator ("default") or the opposite-edge logical operator ("opposite"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean vector representing the logical operator of given type and edge_type. </dd></dl>

</div>
</div>
<a id="a5c00081093c982d4f08828a9d18ecb95" name="a5c00081093c982d4f08828a9d18ecb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c00081093c982d4f08828a9d18ecb95">&#9670;&#160;</a></span>get_logical_operator_default_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; bool &gt; &amp; TISCC::LogicalQubit::get_logical_operator_default_edge </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a boolean vector representing the default-edge logical operator of given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Specifies either the X logical operator ('X') or the Z logical operator ('Z'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the boolean vector representing the default-edge logical operator of given type. </dd></dl>

</div>
</div>
<a id="a97dac5c0253b58e39ad64475a303c302" name="a97dac5c0253b58e39ad64475a303c302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97dac5c0253b58e39ad64475a303c302">&#9670;&#160;</a></span>get_logical_operator_opposite_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; TISCC::LogicalQubit::get_logical_operator_opposite_edge </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a boolean vector representing the opposite-edge logical operator of given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Specifies either the X logical operator ('X') or the Z logical operator ('Z'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean vector representing the opposite-edge logical operator of given type. </dd></dl>

</div>
</div>
<a id="a4a52c5332203217882023ee42f0c434b" name="a4a52c5332203217882023ee42f0c434b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a52c5332203217882023ee42f0c434b">&#9670;&#160;</a></span>get_merged_lq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> * TISCC::LogicalQubit::get_merged_lq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> &amp;&#160;</td>
          <td class="paramname"><em>lq2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and return a logical qubit that represents the merged product of this qubit with an input one. </p>
<p>Currently limited to patches in the standard arrangement. lq2 must be oriented either one tile east-ward or one tile south-ward from the present <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html" title="Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and t...">LogicalQubit</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lq2</td><td><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html" title="Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and t...">LogicalQubit</a> object to be merged with this one. </td></tr>
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object to use in constructing the merged patch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the resultant merged patch. </dd></dl>

</div>
</div>
<a id="a5b341cf782fe323d38e58b0545163a3f" name="a5b341cf782fe323d38e58b0545163a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b341cf782fe323d38e58b0545163a3f">&#9670;&#160;</a></span>get_parity_check_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector&lt; bool &gt; &gt; &amp; TISCC::LogicalQubit::get_parity_check_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get parity check matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to parity check matrix. </dd></dl>

</div>
</div>
<a id="a89d06a54e0dad87ed48de4bcc0c4cc8b" name="a89d06a54e0dad87ed48de4bcc0c4cc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d06a54e0dad87ed48de4bcc0c4cc8b">&#9670;&#160;</a></span>get_qsite_to_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; unsigned int, unsigned int &gt; &amp; TISCC::LogicalQubit::get_qsite_to_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get map from qsite (grid array index) to parity check matrix column. </p>
<p>The parity check matrix actually has twice as many columns. The returned column corresponds with the Z operator. To obtain the column corresponding with the X operator, use lq.get_qsite_to_index()[qsite] + lq.get_qsite_to_index().size(). </p><dl class="section return"><dt>Returns</dt><dd>Const reference to map from qsite (grid array index) to parity check matrix column. </dd></dl>

</div>
</div>
<a id="a46ea50b65c1990ef1d8716c70b80be25" name="a46ea50b65c1990ef1d8716c70b80be25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ea50b65c1990ef1d8716c70b80be25">&#9670;&#160;</a></span>get_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TISCC::LogicalQubit::get_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get hardware grid row specifying the top-left corner of the logical tile on which this patch lives. </p>
<dl class="section return"><dt>Returns</dt><dd>Hardware grid row specifying the top-left corner of the logical tile on which this patch lives. </dd></dl>

</div>
</div>
<a id="a8a41d9aa022a493786142b56c707e019" name="a8a41d9aa022a493786142b56c707e019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a41d9aa022a493786142b56c707e019">&#9670;&#160;</a></span>get_strip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; unsigned int &gt; TISCC::LogicalQubit::get_strip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> &amp;&#160;</td>
          <td class="paramname"><em>lq1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> &amp;&#160;</td>
          <td class="paramname"><em>lq2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns the set of data qsites from this patch that are not occupied by two other input patches. </p>
<p>Typically used to obtain the data qsites between two patches involved in a merge or split operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lq1</td><td></td></tr>
    <tr><td class="paramname">lq2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of data qsites from this patch that are not occupied by two other input patches. </dd></dl>

</div>
</div>
<a id="a723e465dc1227dbbf9dde861ee751a2d" name="a723e465dc1227dbbf9dde861ee751a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723e465dc1227dbbf9dde861ee751a2d">&#9670;&#160;</a></span>hamming_weight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TISCC::LogicalQubit::hamming_weight </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Hamming weight of a given binary vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The Hamming weight of a given binary vector. </dd></dl>

</div>
</div>
<a id="ac622c861692d14c282d5a4d7a541d6b5" name="ac622c861692d14c282d5a4d7a541d6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac622c861692d14c282d5a4d7a541d6b5">&#9670;&#160;</a></span>idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TISCC::LogicalQubit::idle </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hw_master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the hardware circuit for a logical Idle operation (which is a specified number of cycles of syndrome extraction). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycles</td><td>The number of cycles of syndrome extraction. </td></tr>
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object for reference. </td></tr>
    <tr><td class="paramname">hw_master</td><td>The vector of hardware instructions to append this operation to. </td></tr>
    <tr><td class="paramname">time</td><td>The nominal time at which this operation begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nominal time at which this operation ends. </dd></dl>

</div>
</div>
<a id="aabff6a1a8c135b23089d05b162d8d297" name="aabff6a1a8c135b23089d05b162d8d297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabff6a1a8c135b23089d05b162d8d297">&#9670;&#160;</a></span>inject_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TISCC::LogicalQubit::inject_state </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hw_master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a hardware circuit preparing the data qubits for state injection (the state is encoded upon a subsequent Idle operation). </p>
<p>Prepares the top-left corner qubit in the appropriate single-qubit state depending on the given label. Otherwise, prepares data qubits in the |+&gt; state along the default-edge logical X operator and |0&gt; everywhere else. Does not employ post-selection and patch expansion techniques of protocols such as the one proposed in <a href="https://arxiv.org/abs/1410.7808">https://arxiv.org/abs/1410.7808</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>State label. Options: 'y', 't'. </td></tr>
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object for reference. </td></tr>
    <tr><td class="paramname">hw_master</td><td>The vector of hardware instructions to append this operation to. </td></tr>
    <tr><td class="paramname">time</td><td>The nominal time at which this operation begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nominal time at which this operation ends. </dd></dl>

</div>
</div>
<a id="a5eaf6d63d14128a68d24c7e0e7c68e57" name="a5eaf6d63d14128a68d24c7e0e7c68e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eaf6d63d14128a68d24c7e0e7c68e57">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TISCC::LogicalQubit::merge </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hw_master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the hardware circuit for a merge operation. </p>
<p>This is only a valid operation on <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html" title="Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and t...">LogicalQubit</a> objects that had been returned by get_merged_lq. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycles</td><td>The number of cycles of syndrome extraction. </td></tr>
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object for reference. </td></tr>
    <tr><td class="paramname">hw_master</td><td>The vector of hardware instructions to append this operation to. </td></tr>
    <tr><td class="paramname">time</td><td>The nominal time at which this operation begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nominal time at which this operation ends. </dd></dl>

</div>
</div>
<a id="a274ffd4ead94d8b5020c7487d2e5bc8a" name="a274ffd4ead94d8b5020c7487d2e5bc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274ffd4ead94d8b5020c7487d2e5bc8a">&#9670;&#160;</a></span>move_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TISCC::LogicalQubit::move_right </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> *&amp;&#160;</td>
          <td class="paramname"><em>lq_extended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html">LogicalQubit</a> *&amp;&#160;</td>
          <td class="paramname"><em>lq_contracted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hw_master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the hardware circuit for the Move Right operation (see Fig. 4 of the TISCC paper). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycles</td><td>The number of cycles of syndrome extraction. </td></tr>
    <tr><td class="paramname">lq_extended</td><td>Exchanges a nullptr for a pointer to the <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html" title="Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and t...">LogicalQubit</a> corresponding with the intermediate extended patch. </td></tr>
    <tr><td class="paramname">lq_contracted</td><td>Exchanges a nullptr for a pointer to the <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html" title="Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and t...">LogicalQubit</a> corresponding with the final contracted patch. </td></tr>
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object for reference. </td></tr>
    <tr><td class="paramname">hw_master</td><td>The vector of hardware instructions to append this operation to. </td></tr>
    <tr><td class="paramname">time</td><td>The nominal time at which this operation begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nominal time at which this operation ends. </dd></dl>

</div>
</div>
<a id="ae3d1017f4cf11d9f9c7f0a7922a13006" name="ae3d1017f4cf11d9f9c7f0a7922a13006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d1017f4cf11d9f9c7f0a7922a13006">&#9670;&#160;</a></span>occupied_sites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; unsigned int &gt; TISCC::LogicalQubit::occupied_sites </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>just_data_qubits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a set of qsites occupied by the plaquettes of this patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">just_data_qubits</td><td>Specifies whether only data qubits (not syndrome measurement qubits) should be included. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of qsites occupied by the plaquettes of patch. </dd></dl>

</div>
</div>
<a id="a0816ab857b409eb757ef255e336ddee6" name="a0816ab857b409eb757ef255e336ddee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0816ab857b409eb757ef255e336ddee6">&#9670;&#160;</a></span>operator_product_binary_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; bool &gt;, int &gt; TISCC::LogicalQubit::operator_product_binary_format </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the product of two operators expressed in binary symplectic format. </p>
<dl class="section return"><dt>Returns</dt><dd>A pair with the binary symplectic vector on one hand and a sign on the other. </dd></dl>

</div>
</div>
<a id="a42053ea5aff93523737b6bac4aa9de6e" name="a42053ea5aff93523737b6bac4aa9de6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42053ea5aff93523737b6bac4aa9de6e">&#9670;&#160;</a></span>pauli_string_to_binary_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; bool &gt;, std::complex&lt; double &gt; &gt; TISCC::LogicalQubit::pauli_string_to_binary_operator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pauli_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform operators from string to binary symplectic representation, tracking phase e.g. ZYIX -&gt; -i*(11000101) </p>
<dl class="section return"><dt>Returns</dt><dd>A pair with the binary symplectic vector on one hand and a phase on the other. </dd></dl>

</div>
</div>
<a id="a11d51da95d287b4c7c33ab245c0dc4ef" name="a11d51da95d287b4c7c33ab245c0dc4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d51da95d287b4c7c33ab245c0dc4ef">&#9670;&#160;</a></span>print_parity_check_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TISCC::LogicalQubit::print_parity_check_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints out the parity check matrix stored by this patch and some ancillary data. </p>
<p>Also checks and returns validity of parity check matrix. </p>

</div>
</div>
<a id="ace2c0ac011986f5629195b485e5d9cb6" name="ace2c0ac011986f5629195b485e5d9cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2c0ac011986f5629195b485e5d9cb6">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TISCC::LogicalQubit::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hw_master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the hardware circuit for a split operation. </p>
<p>This is only a valid operation on <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html" title="Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and t...">LogicalQubit</a> objects that had been returned by get_merged_lq. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object for reference. </td></tr>
    <tr><td class="paramname">hw_master</td><td>The vector of hardware instructions to append this operation to. </td></tr>
    <tr><td class="paramname">time</td><td>The nominal time at which this operation begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nominal time at which this operation ends. </dd></dl>

</div>
</div>
<a id="a287aca5389ad91b10ec61e3a8fb95ae2" name="a287aca5389ad91b10ec61e3a8fb95ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287aca5389ad91b10ec61e3a8fb95ae2">&#9670;&#160;</a></span>swap_left()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double TISCC::LogicalQubit::swap_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hw_master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the hardware circuit for the Swap Left operation (see Fig. 4 of the TISCC paper). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object for reference. </td></tr>
    <tr><td class="paramname">hw_master</td><td>The vector of hardware instructions to append this operation to. </td></tr>
    <tr><td class="paramname">time</td><td>The nominal time at which this operation begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nominal time at which this operation ends. </dd></dl>

</div>
</div>
<a id="a001f1a2bfeb8ca3f454e7588678f2bc0" name="a001f1a2bfeb8ca3f454e7588678f2bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001f1a2bfeb8ca3f454e7588678f2bc0">&#9670;&#160;</a></span>symplectic_transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; TISCC::LogicalQubit::symplectic_transform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symplectic transform of a binary symplectic vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The transformed vector. </dd></dl>

</div>
</div>
<a id="a79e884d65fa0aa5203f2a0bfab56f272" name="a79e884d65fa0aa5203f2a0bfab56f272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e884d65fa0aa5203f2a0bfab56f272">&#9670;&#160;</a></span>transversal_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TISCC::LogicalQubit::transversal_op </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_t_i_s_c_c_1_1_h_w___instruction.html">HW_Instruction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hw_master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the hardware circuit for a given transversal operation (acts on all data qubits of the patch). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Operation label. Options: "prepz", "prepx", "measz", "measx", and "hadamard". </td></tr>
    <tr><td class="paramname">grid</td><td>The <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html" title="Provides access to an array representing a grid-like trapped-ion hardware architecture with a particu...">GridManager</a> object for reference. </td></tr>
    <tr><td class="paramname">hw_master</td><td>The vector of hardware instructions to append this operation to. </td></tr>
    <tr><td class="paramname">time</td><td>The nominal time at which this operation begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nominal time at which this operation ends. </dd></dl>

</div>
</div>
<a id="a69de438a0adb82c276f2d5c69d2cc387" name="a69de438a0adb82c276f2d5c69d2cc387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69de438a0adb82c276f2d5c69d2cc387">&#9670;&#160;</a></span>xz_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TISCC::LogicalQubit::xz_swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_i_s_c_c_1_1_grid_manager.html">GridManager</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap roles of X and Z operators for this patch. </p>
<p>Typically used to transform operators following a transversal Hadamard or to obtain a <a class="el" href="class_t_i_s_c_c_1_1_logical_qubit.html" title="Manages the Plaquettes of a surface code patch and offers functionality both to manipulate them and t...">LogicalQubit</a> object with a rotated stabilizer arrangement. </p>

</div>
</div>
<a id="a8c70aa12d07fb39ed286e092d2048617" name="a8c70aa12d07fb39ed286e092d2048617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c70aa12d07fb39ed286e092d2048617">&#9670;&#160;</a></span>xz_swap_tracker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TISCC::LogicalQubit::xz_swap_tracker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if xz_swap has been applied to this patch and False otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>True if xz_swap has been applied to this patch and False otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/TISCC/<a class="el" href="logicalqubit_8hpp_source.html">logicalqubit.hpp</a></li>
<li>src/<b>logicalqubit.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
